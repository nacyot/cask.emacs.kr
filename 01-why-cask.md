---
title: 왜 Cask인가?
layout: default
permalink: why-cask.html
---

## 왜 Cask인가?

---

이 문서는 Cask가 Emacs 설정을 관리하거나 Emacs Lisp 패키지 개발하는 데 왜 필요한 지 설명합니다.

### Emacs Lisp 패키지 개발

자 그럼 왜 Emacs Lisp 프로젝트를 진행하는 데 Cask가 필요할까요? 여러분은 이미 답을 알고있습니다.

* Ruby 프로젝트에는 `Gemfile`이 있죠?
* Node.js 프로젝트에는 `package.json`이 있죠?
* Clojure 프로젝트에는 `project.clj`가 있죠?
* Emacs Lisp 프로젝트에는 `Cask` 파일이 있죠?


마지막 문장을 조금 다듬어 보죠.

* Emacs Lisp 프로젝트 중에는 `Cask` 파일이 있는 경우도 있죠?


아뇨. 한 번 더.

* Emacs Lisp 프로젝트 중에는 `Cask` 파일이 없는 경우도 있죠?


일부 Emacs Lisp 프로젝트는 Cask가 굳이 필요하지 않을 수도 있습니다. 아래의 프로젝트들이 그런 예입니다.

* 의존 라이브러리가 없는 프로젝트
* 테스트가 없는 프로젝트
* 일관성에 게의치 않는 프로젝트
* 컴파일러 경고에 게의치 않는 프로젝트
* 사람들이 참여에 무관심한 프로젝트

하나 같이 사용하기 어려운 프로젝트들이죠.

Emacs 패키지 개발은 지난 몇년간 놀라울 정도로 발전했습니다. 예전에는 Emacs Lisp 파일 하나를 Emacs 위키에 업로드했습니다. 이런 상황에서 벗어나 이제는 VCS에 잘 완성된 패키지들을 올리고, 테스트도 하고, 나아가 패키지 매니저로 설치할 수 있는 등 많은 변화가 있었습니다.

하지만 이러한 발전에도 불구하고 일관성에 관한 부분만은 여전히 발전이 없었습니다. *모든* Ruby 프로젝트에는 `gemspec` 파일이 있고, *모든* Node.js 프로젝트에는 `package.json` 파일이 있고, *모든* Clojure 프로젝트에는 `project.clj` 파일이 있습니다.

이러한 환경 위에서 프로젝트는 일관성 있게 구성되며 일관성 있게 테스트되고 일관성 있게 패키징되고 일관성 있게 컴파일되며 일관성 있게 배포됩니다. 새로운 프로젝트를 찾아 이 프로젝트가 의존하고 있는 라이브러리를 확인하고자 할 때 어디에 이러한 정보가 있는 지는 항상 정해져있습니다. 특정 기능의 테스트도 당연히 있어야할 곳에 있습니다.

Cask를 사용한다면 Emacs Lisp 프로젝트도 그렇게 됩니다.

자신의 Emacs Lisp 프로젝트에 직접적인 필요가 없어보이더라도 Cask는 필요합니다. 나뿐만 아니라 다른 Emacs Lisp 개발자들을 위해서 사용하시기 바랍니다.

### Emacs 설정

여러 Emacs 설정을 보신 적이 있다면, 몇 가지 자주 사용되는 설정 방법이 있다는 걸 알고 있겠죠. 아래에서는 각각의 방법의 장단점을 살펴봅니다.

#### El-get

El-get이 나왔을 때는 다른 대안이 없었기에 금방 유명해질 수 있었습니다. 지금은 대안은 물론 Emacs 개발팀이 선택한 `package.el`이라는 표준적인 도구가 있습니다. El-get은 훌륭한 도구였지만 지금은 오래된 도구입니다. 표준적인 방법을 사용하시길 바랍니다!

#### package.el 직접 사용하기

`package.el`은 보통 다음과 같이 사용됩니다.

{% highlight cl %}
(require 'package)
(package-initialize)
(mapc
 (lambda (package)
   (unless (package-installed-p package)
     (package-install package)))
 '(s f dash flycheck prodigy ...))
{% endhighlight %}

저도 한 때는 이러한 방식을 사용했습니다. 이제는 Cask가 있기 때문에 이런 방식은 사용하지 않습니다.

#### 서브 모듈

제 Emacs 설정 파일에는 60개 이상의 패키지가 정의되어 있습니다. 이 정도 개수의 패키지들을 서브모듈 기능으로 최신버전으로 관리한다고 하면, 상상이나 가시나요?

#### 번들된 패키지(의존 라이브러리를 포함한 패키지)

이 방법은 서브모듈을 통한 접근과 마찬가지로 최신 버전을 유지하는 데 애로사항이 따릅니다. 상황은 더 나쁩니다. 의존 라이브러리들을 패키지 저장소에 포함 시켜놓는 건 사람을 미치게 만듭니다. 제가 굳이 설명할 필요 없겠죠?

#### Cask

우리가 원하던 건 바로 이겁니다. Cask를 통해 모든 의존 라이브러리를 하나의 파일에 정의하고 관리할 수 있습니다. 의존 라이브러리와 그 설정이 어디있는지 쉽게 찾을 수 있을 뿐 아니라 최신 버전으로 업그레이드하는 것도 쉽습니다.
